#!/usr/bin/env bash

# Source the script '.common-functions.sh'.
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
ROOT_DIR=$(grep --only-matching "^.*scripts[^/]*" <<<"$SCRIPT_DIR")
source "$ROOT_DIR/.common-functions.sh"

_main() {
    local input_files=""

    # Execute initial checks.
    _check_dependencies "gpg"
    _display_wait_box
    input_files=$(_get_files "par_type=file; par_select_mime='application/octet-stream|application/pgp|application/pgp-encrypted|application/pgp-signature|text/PGP|text/plain'")

    # Execute the function '_main_task' for each file in parallel.
    _run_task_parallel "$input_files" ""

    local std_output=""
    std_output=$(_storage_text_read_all)
    #std_output=$(_text_sort "$std_output")
    std_output=$(sort --version-sort --reverse <<<"$std_output")

    # Translate some strings from the '$std_output'.
    # shellcheck disable=SC2001
    std_output=$(sed "s|__MSG_Valid__|$(_i18n 'Valid signature')|g" <<<"$std_output")
    # shellcheck disable=SC2001
    std_output=$(sed "s|__MSG_Invalid__|$(_i18n 'Invalid signature')|g" <<<"$std_output")
    # shellcheck disable=SC2001
    std_output=$(sed "s|__MSG_NoKey__|$(_i18n 'Missing key')|g" <<<"$std_output")
    # shellcheck disable=SC2001
    std_output=$(sed "s|__MSG_NoData__|$(_i18n 'Missing datafile')|g" <<<"$std_output")

    _display_list_box "$std_output" "par_item_name=$(_i18n 'files'); par_columns='--column:$(_i18n 'Status'),--column:$(_i18n 'Name'),--column:$(_i18n 'E-mail'),--column:$(_i18n 'Key ID'),--column:$(_i18n 'Date'),--column:$(_i18n 'Time'),--column:$(_i18n 'File')'; par_action=open_location; par_check_type=checkbox"
}

_main_task() {
    local input_file=$1
    local std_output=""
    local status="__MSG_Unknown__"
    local name=" "
    local email=" "
    local key_id=" "
    local date=" "
    local time=" "
    local timestamp=""

    # Run the main process.
    std_output=$(LC_ALL=C gpg --yes --status-fd=1 --verify -- "$input_file" 2>&1)

    if grep --quiet --ignore-case "\[GNUPG:\] GOODSIG" <<<"$std_output"; then
        status="ðŸŸ¢ __MSG_Valid__"
    elif grep --quiet --ignore-case "\[GNUPG:\] BADSIG" <<<"$std_output"; then
        status="ðŸ”´ __MSG_Invalid__"
    elif grep --quiet --ignore-case "\[GNUPG:\] NO_PUBKEY" <<<"$std_output"; then
        status="âšª __MSG_NoKey__"
    elif grep --quiet --ignore-case "can't hash datafile" <<<"$std_output"; then
        status="âšª __MSG_NoData__"
    else
        return 1
    fi

    if [[ "$status" == *"__MSG_Valid__"* || "$status" == *"__MSG_Invalid__"* ]]; then
        local sig_line=""
        sig_line=$(grep --ignore-case --perl-regexp "\[GNUPG:\] (BAD|GOOD)SIG" <<<"$std_output")
        key_id=$(cut -d " " -f3 <<<"$sig_line")
        local user=""
        user=$(cut -d " " -f4- <<<"$sig_line")
        user=$(sed "s| <|$FIELD_SEPARATOR|g; s|>$||g" <<<"$user")
        name=$(cut -d "$FIELD_SEPARATOR" -f1 <<<"$user")
        email=$(cut -d "$FIELD_SEPARATOR" -f2 <<<"$user")
        if [[ "$status" == *"__MSG_Valid__"* ]]; then
            local validsig_line=""
            validsig_line=$(grep --ignore-case "\[GNUPG:\] VALIDSIG" <<<"$std_output")
            timestamp=$(awk '{print $5}' <<<"$validsig_line")
        fi
    elif [[ "$status" == *"__MSG_NoKey__"* ]]; then
        local no_pubkey_line=""
        no_pubkey_line=$(grep --ignore-case "\[GNUPG:\] NO_PUBKEY" <<<"$std_output")
        key_id=$(cut -d " " -f3 <<<"$no_pubkey_line")
        local errsig_line=""
        errsig_line=$(grep --ignore-case "\[GNUPG:\] ERRSIG" <<<"$std_output")
        timestamp=$(awk '{print $7}' <<<"$errsig_line")
    fi

    if [[ -n "$timestamp" ]]; then
        date=$(date -d "@$timestamp" "+%Y-%m-%d")
        time=$(date -d "@$timestamp" "+%H:%M:%S %z")
    fi

    _storage_text_write_ln "${status}${FIELD_SEPARATOR}${name}${FIELD_SEPARATOR}${email}${FIELD_SEPARATOR}${key_id}${FIELD_SEPARATOR}${date}${FIELD_SEPARATOR}${time}${FIELD_SEPARATOR}$(_text_remove_pwd "$input_file")"
}

_main "$@"
