#!/usr/bin/env bash

# Source the script '.common-functions.sh'.
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
ROOT_DIR=$(grep --only-matching "^.*scripts[^/]*" <<<"$SCRIPT_DIR")
source "$ROOT_DIR/.common-functions.sh"

_main() {
    local input_files=""
    local output_dir=""

    # Execute initial checks.
    _check_dependencies "nmap ping"
    _display_wait_box
    input_files=$(_get_files "par_type=all")

    # Export functions to be used inside new shells (when using 'xargs').
    export -f _resolve_host

    # Execute the function '_main_task' for each ip in parallel (127 threads).
    _run_task_parallel "$(_prepare_input "$input_files")" "$output_dir" "127"

    local std_output=""
    std_output=$(_storage_text_read_all)
    std_output=$(sort --version-sort --reverse <<<"$std_output")

    # Translate some strings from the '$std_output'.
    # shellcheck disable=SC2001
    std_output=$(sed "s|__MSG_Online__|$(_i18n 'Online')|g" <<<"$std_output")
    # shellcheck disable=SC2001
    std_output=$(sed "s|__MSG_Offline__|$(_i18n 'Offline')|g" <<<"$std_output")

    _display_list_box "$std_output" "par_item_name=$(_i18n 'IPs'); par_columns='--column:$(_i18n 'Status'),--column:$(_i18n 'IP'),--column:$(_i18n 'Hostname'),--column:$(_i18n 'Ping'),--column:$(_i18n 'Ports')'"
}

_main_task() {
    local input_file=$1
    local output_dir=$2
    local timeout_value=2
    local ip=$input_file
    local status=""
    local ping=""
    local ports=""

    # Run ping and extract only the result from the last ICMP packet.
    ping=$(LC_ALL=C ping -n -c 3 -W "$timeout_value" -- "$input_file" 2>/dev/null |
        grep -E "icmp_seq=3" | grep -o "time=.*" | cut -d "=" -f 2)

    # Perform an Nmap scan to detect open ports.
    ports=$(LC_ALL=C nmap -n -Pn -T4 --max-retries 1 --host-timeout "$timeout_value"s "$ip" 2>/dev/null |
        awk '/open/ {split($1, a, "/"); print a[1]}' | paste -s -d ",")

    if [[ -z "$ping" && -z "$ports" ]]; then
        # Use Nmap host discovery (no port scan) to see if the host replies.
        if LC_ALL=C nmap -sn --host-timeout "$timeout_value"s "$ip" 2>/dev/null |
            grep --quiet --ignore-case "Host is up"; then
            status="__MSG_Online__"
        fi
    fi

    # Determine final status.
    if [[ -n "$ports" ]]; then
        status="ðŸŸ¢ __MSG_Online__"
    elif [[ -n "$ping" ]]; then
        status="ðŸ”µ __MSG_Online__"
    elif [[ -n "$status" ]]; then
        status="ðŸ”µ __MSG_Online__"
    else
        status="ðŸ”´ __MSG_Offline__"
    fi

    # Resolve hostname. If empty, set as unknown.
    local hostname=""
    hostname=$(_resolve_host "$ip")

    _storage_text_write_ln "$status$FIELD_SEPARATOR$ip$FIELD_SEPARATOR$hostname$FIELD_SEPARATOR$ping$FIELD_SEPARATOR$ports"
}

_extract_ips() {
    local data=$1
    local output=""
    local ip=""
    local base=""
    local start=""
    local end=""

    if [[ -z "$data" ]]; then
        return
    fi

    # Extract:
    #   - Single IPs
    #   - IP ranges (192.168.1.1-254)
    #   (CIDR notation like 192.168.1.0/24 is ignored)
    data=$(grep -oP '\b(?:(?:25[0-5]|2[0-4]\d|1?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|1?\d?\d)(?:-\d{1,3})?\b' <<<"$data")

    # Expand IP ranges.
    while read -r ip; do
        # Case: IP range (e.g., 192.168.1.1-254).
        if [[ "$ip" =~ ^([0-9]+\.[0-9]+\.[0-9]+)\.([0-9]+)-([0-9]+)$ ]]; then
            base="${BASH_REMATCH[1]}"
            start="${BASH_REMATCH[2]}"
            end="${BASH_REMATCH[3]}"
            for ((i = start; i <= end; i++)); do
                output+="$base.$i"$'\n'
            done
        # Case: Single IP.
        else
            output+="$ip"$'\n'
        fi
    done <<<"$data"

    output=$(sort --unique <<<"$output")
    output=$(_text_remove_empty_lines "$output")

    printf "%s" "$output"
}

_get_local_range() {
    local ip=""
    ip=$(hostname -I 2>/dev/null | awk '{print $1}')

    if [[ -z "$ip" ]]; then
        ip="192.168.0.1"
    fi

    local base=""
    base=$(cut -d. -f1-3 <<<"$ip")

    printf "%s" "${base}.1-254"
}

_prepare_input() {
    local input_files=$1
    local data=""
    local ips=""
    local msg=""

    # shellcheck disable=SC2086
    data=$(cat -- $input_files 2>/dev/null)
    ips=$(_extract_ips "$data")

    if [[ -z "$ips" ]]; then
        local local_range=""
        local_range=$(_get_local_range)

        msg+="$(_i18n 'Enter IP addresses or IP ranges.')"
        msg+="\n\n"
        msg+="$(_i18n 'Example:') 192.168.0.1-10, 192.168.100.1"
        data=$(_display_input_text_box "$msg" "$local_range")
        ips=$(_extract_ips "$data")
    fi

    if [[ -z "$ips" ]]; then
        msg="$(_i18n 'There are no valid IPs in the input!')"
        _display_error_box "$msg"
        _exit_script
    fi

    _convert_text_to_delimited_string "$ips"
}

_resolve_host() {
    local ip=$1
    local hostname=""

    # Try local resolution.
    hostname=$(grep -F "$ip" </etc/hosts | awk '{print $2}' | head -n1)

    if [[ -n "$hostname" ]]; then
        printf "%s" "$hostname"
        return 0
    fi

    # Try SSH config files.
    hostname=$(grep -i -r -h -B3 "Hostname .*$ip" "$HOME/.ssh/" 2>/dev/null |
        grep -i "Host " | awk '{print $2}' | head -n 1)

    if [[ -n "$hostname" ]]; then
        printf "%s" "$hostname"
        return 0
    fi

    # If not found locally, try online resolution.
    if _command_exists "host"; then
        hostname=$(host "$ip" | awk '/domain name pointer/ {print $5}')
    elif _command_exists "dig"; then
        hostname=$(dig -x "$ip" +short)
    fi

    # shellcheck disable=SC2001
    hostname=$(sed "s|\.$||" <<<"$hostname")

    printf "%s" "$hostname"
}

_main "$@"
